#!/usr/bin/perl
use strict;
use warnings;

use lib '/usr/local/pf/lib';
use pf::config;
use feature "say";
use Log::Log4perl;
use Readonly;
use JSON;
use HTTP::Headers;
use HTTP::Request;
use LWP::UserAgent;

# Configuration parameter
Readonly::Scalar my $WEBAPI_SCHEME   => 'http';
Readonly::Scalar my $WEBAPI_PORT     => $Config{'ports'}{'soap'};
Readonly::Scalar my $WEBAPI_RESOURCE => 'json';
Readonly::Scalar my $WEBAPI_URI      => 
    $WEBAPI_SCHEME . '://' . 'localhost' . ':' . $WEBAPI_PORT . '/' . $WEBAPI_RESOURCE;

print STDERR "Loaded the perl snmptrapd handler\n";

NetSNMP::TrapReceiver::register( "all", \&trap_receiver )
    || warn "failed to register our perl trap handler\n";

sub trap_receiver {
    my %PDU      = %{ $_[0] };
    my @VARBINDS = @{ $_[1] };

    my $logger = Log::Log4perl->get_logger('pftraplistener');
    
    # map the variable bindings to a hash where key is OID and value is a string containing type and value
    my %VARBINDS
        = map { $_->[0] => ( sprintf "type=%-2d value=%s", $_->[2], $_->[1] ); } @VARBINDS;

    my %trap = (
        PDU      => \%PDU,
        VARBINDS => \%VARBINDS,
        PFTYPE   => undef,
    );
    $trap{"PFTYPE"} = "snmptrap";
    
    # build the HTTP request and the JSON payload
    my $json = encode_json \%trap;
    my $req = HTTP::Request->new( 'POST', $WEBAPI_URI );
    $req->header( 'Content-Type' => 'application/json' );
    $req->header( 'Request'      => 'snmptrap' );
    $req->content($json);

    # send the request
    my $lwp = LWP::UserAgent->new;
    $logger->info( "Calling WebAPI with snmptrap request received from " . $trap{'PDU'}->{'receivedfrom'} );
    my $response = $lwp->request($req);
    unless ( $response->is_success ) {
        $logger->error( "WebAPI error in reply to snmptrap request: " . $response->status_line );
        return undef;
    }

    return 1;

}

